- **Deepcopy**: 深复制，即将被复制对象完全再复制一遍作为**独立的新个体**单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。 
    ```python
    import copy

    l1 = [1,2,3]
    l2 = copy.deepcopy(l1)

    l2[0] = 999 

    print(id(l1),l1)
    print(id(l2),l2)
    ```
    Returns:
    ```python
    4542925128 [1, 2, 3]
    4542822600 [999, 2, 3]
    ```

- **Assignment**: 而等于赋值，并不会产生一个独立的对象单独存在，他**只是将原有的数据块打上一个新标签**，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。
    ```python
    a = 123
    b = a

    b = 1000

    print(id(a),a)
    print(id(b),b)
    ```
    **Returns????**:
    ```python
    4417987824 123
    4419383024 1000
    ```
    结果不一样是因为，b再次赋值到了另一个数据块，不属于改变了原数据块！
    
    ```python
    l1 = [1,2,3]
    l2 = l1

    l2[0] = 999 

    print(id(l1),l1)
    print(id(l2),l2)
    ```
    Return:
    ```python
    4525120968 [999, 2, 3]
    4525120968 [999, 2, 3]
    ```

- **Copy**: 而浅复制要分两种情况进行讨论：

    1. 当浅复制的值是**不可变对象**（数值，字符串，元组）时和“**等于赋值**”的情况一样，对象的**id值与浅复制原来的值相同**。
        ```python
        import copy

        a = '12345'
        b = copy.copy(a)

        print(id(a),a)
        print(id(b),b)
        ```
        Return:
        ```python
        4446201088 12345
        4446201088 12345
        ```

    2. 当浅复制的值是**可变对象** (列表和元组) 时会产生一个“不是那么独立的对象”存在。**id不同**. 有两种情况：

        1. 第一种情况：复制的 对象中 **无复杂** 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。**相当于 deepcopy**
              ```python
              l1 = [1,2,3]
              l2 = l1.copy()

              l2[0] = 999 

              print(id(l1),l1)
              print(id(l2),l2)
              ```
              Return:
              ```python
              4391409992 [1, 2, 3]
              4391307464 [999, 2, 3]
              ```

        2. 第二种情况：复制的对象中有 **复杂子对象** （例如列表中的一个子元素是一个列表)

            - 如果不改变其中复杂子对象，浅复制的值改变并不会影响原来的值。 
                ```python
                l1 = [1,2,['a','b']]
                l2 = l1.copy()

                l2[0] = 999 

                print(id(l1),l1)
                print(id(l2),l2)
                ```   
                Return:
                ```python
                4328782856 [1, 2, ['a', 'b']]
                4328782152 [999, 2, ['a', 'b']]
                ```
            - 但是改变原来的值 中的复杂子对象的值  会影响浅复制的值。
                ```python
                l1 = [1,2,['a','b']]
                l2 = l1.copy()

                l1[2].append(999) 

                print(id(l1),l1)
                print(id(l2),l2)
                ```   
                Return:
                ```python
                4411014152 [1, 2, ['a', 'b', 999]]
                4411013448 [1, 2, ['a', 'b', 999]]
                ```

### In summary:

- 对于简单的 object，例如不可变对象（数值，字符串，元组），用 shallow copy 和 deep copy 没区别

- 复杂的 object， 如 list 中套着 list 的情况，shallow copy 中的 子list，并未从原 object 真的「独立」出来。也就是说，如果你改变原 object 的子 list 中的一个元素，你的 copy 就会跟着一起变。这跟我们直觉上对「复制」的理解不同。



[reference](https://blog.csdn.net/u011630575/article/details/78604226)
